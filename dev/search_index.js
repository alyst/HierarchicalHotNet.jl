var documenterSearchIndex = {"docs":
[{"location":"network_diffusion.html#netdiff","page":"Network Diffusion","title":"Network diffusion","text":"","category":"section"},{"location":"network_diffusion.html","page":"Network Diffusion","title":"Network Diffusion","text":"HierarchicalHotNet.stepmatrix\nHierarchicalHotNet.random_walk_matrix\nHierarchicalHotNet.similarity_matrix\nHierarchicalHotNet.neighborhood_weights","category":"page"},{"location":"network_diffusion.html#HierarchicalHotNet.stepmatrix","page":"Network Diffusion","title":"HierarchicalHotNet.stepmatrix","text":"Construct the step matrix for the random walk.\n\n\n\n\n\n","category":"function"},{"location":"network_diffusion.html#HierarchicalHotNet.random_walk_matrix","page":"Network Diffusion","title":"HierarchicalHotNet.random_walk_matrix","text":"Find the matrix that transforms given initial node probabilities into stationary distribution of visiting probabilities of a random walk with restart.\n\n\n\n\n\n","category":"function"},{"location":"network_diffusion.html#Network-Permutation","page":"Network Diffusion","title":"Network Permutation","text":"","category":"section"},{"location":"network_diffusion.html","page":"Network Diffusion","title":"Network Diffusion","text":"One way to confirm the relevance of network diffusion-based predictions is to show that the results based on real the data differ significantly from the ones based on randomized data, where no meaningful patterns are expected. One scheme for generating realistic randomized dataset, proposed in the original paper, is to group the vertices with similar in- and out-degrees into bins and randomly shuffle the weights of the vertices within each bin. In this scheme, the weights of hubs are randomly reassigned to other hubs, and low-degree vertices to other low-degree vertices, so that overall the distribution of weights across the nodes looks very similar to real experiments, except that any correlations between the vertex weights and biological pathways are distrupted.","category":"page"},{"location":"network_diffusion.html","page":"Network Diffusion","title":"Network Diffusion","text":"HierarchicalHotNet.vertexbins\nHierarchicalHotNet.randpermgroups!\nHierarchicalHotNet.randpermgroups","category":"page"},{"location":"network_diffusion.html#HierarchicalHotNet.vertexbins","page":"Network Diffusion","title":"HierarchicalHotNet.vertexbins","text":"vertexbins(g::AbstractSimpleWeightedGraph,\n           vertices::AbstractArray{Int}=1:nv(g);\n           nbins::Integer=10, by::Symbol=:out, method=:tree) ->\n    IndicesPartition\n\nPartition the vertices of the weighted graph g into nbins bins, so that the vertices of the same bin have similar sum of edge weights.\n\nKeyword arguments\n\nnbins::Integer: the number of vertex bins. Use nbins &ge; 1 for  bigger (nv &ge; 1) networks\nby::Symbol: what edges to consider for grouping vertices. The supported options are:\n:out (default, as in the original paper) – use only the outgoing edges\n:in – use only the incoming edges\n:outXin (recommended) – use all edges, so that the vertices of the same bin have similar sums of both incoming and outgoing edges\nmethod::Symbol: the method for binning vertices\n:sort (as in the original paper) – order the vertices by the sum of weights, then split the sorted array into equal bins. This method doesn't handle the by=:outXin well.\n:tree (default) – build the hierarchical tree of vertices based on their sum of weights, then cut the tree to get the requested number of bins.\n\n\n\n\n\n","category":"function"},{"location":"network_diffusion.html#HierarchicalHotNet.randpermgroups!","page":"Network Diffusion","title":"HierarchicalHotNet.randpermgroups!","text":"randpermgroups!(v::AbstractVector{Int}, groups::AbstractPartition) -> v\n\nRandomly reshuffle the elements of groups within each group and put the result into v, group by group.\n\n\n\n\n\n","category":"function"},{"location":"network_diffusion.html#HierarchicalHotNet.randpermgroups","page":"Network Diffusion","title":"HierarchicalHotNet.randpermgroups","text":"randpermgroups(groups::AbstractPartition) -> Vector{Int}\n\nRandomly reshuffle the elements of groups within each group.\n\n\n\n\n\n","category":"function"},{"location":"index.html#HierarchicalHotNet.jl-package","page":"Introduction","title":"HierarchicalHotNet.jl package","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"HierarchicalHotNet.jl implements Hierarchical HotNet algorithm (see the original paper by M.A. Reyna et al) with a few permormance optimization and additional features.","category":"page"},{"location":"index.html#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"scctree.html#scctree","page":"SCC Tree","title":"Strongly Connected Components tree","text":"","category":"section"},{"location":"scctree.html","page":"SCC Tree","title":"SCC Tree","text":"HierarchicalHotNet.SCCTree\nHierarchicalHotNet.scctree\nHierarchicalHotNet.cut","category":"page"},{"location":"scctree.html#HierarchicalHotNet.SCCTree","page":"SCC Tree","title":"HierarchicalHotNet.SCCTree","text":"The tree of strongly connected components. Organizes the strongly connected components of the weighted directed graph into a tree.\n\nCutting the tree at specific threshold with cut gives the corresponding strongly connected components. The root of the tree corresponds to the weakest threshold.\n\n\n\n\n\n","category":"type"},{"location":"scctree.html#HierarchicalHotNet.scctree","page":"SCC Tree","title":"HierarchicalHotNet.scctree","text":"scctree(g::Union{AbstractSimpleWeightedGraph, AbstractMatrix};\n        method=:bisect, skipval=0, rev=false) -> SCCTree\n\nComputes the hierarchical decomposition of a weighted directed graph into strongly connected components.\n\nArguments\n\ng::AbstractSimpleWeightedGraph: the graph (or its adjcency matrix  representation) to partition into components\nmethod::Symbol, defaults to :bisect: the method for partitioning.  The supported methods are :bisect (the fastest) and :bottomup (slow,  but simpler).\nskipval::Number, defaults to zero: what value of the adjacency matrix  should be treated as no edge.\nrev::Bool, default to false: if true, bigger edges weights are considered  weaker than smaller ones\n\n\n\n\n\n","category":"function"},{"location":"scctree.html#HierarchicalHotNet.cut","page":"SCC Tree","title":"HierarchicalHotNet.cut","text":"cut(tree, threshold; minsize=1) -> IndicesPartition\n\nCuts the tree at the given threshold to get the corresponding strongly connected components of the original graph. minsize optional parameter specifies whether components smaller than that would be ignored.\n\n\n\n\n\n","category":"function"},{"location":"utils.html#partition","page":"Utilities","title":"Partitions","text":"","category":"section"},{"location":"utils.html","page":"Utilities","title":"Utilities","text":"Partition is an efficient way to store multiple vectors of elements. The advantage over Vector{Vector{T}} is that internally it uses the single container to store the elements of all its parts. The disadvantage is that it doesn't support adding or removing elements to/from arbitrary part, only the last part could be modified. Partition supports iterator interface for iterating over its parts as well as parts indexing and filter! for elements filtering.","category":"page"},{"location":"utils.html","page":"Utilities","title":"Utilities","text":"HierarchicalHotNet.AbstractPartition\nHierarchicalHotNet.PartitionPart\nHierarchicalHotNet.Partition","category":"page"},{"location":"utils.html#HierarchicalHotNet.AbstractPartition","page":"Utilities","title":"HierarchicalHotNet.AbstractPartition","text":"Base class for partitions of elements of type T.\n\n\n\n\n\n","category":"type"},{"location":"utils.html#HierarchicalHotNet.PartitionPart","page":"Utilities","title":"HierarchicalHotNet.PartitionPart","text":"The type of parts returned by Partition{T}\n\n\n\n\n\n","category":"type"},{"location":"utils.html#HierarchicalHotNet.Partition","page":"Utilities","title":"HierarchicalHotNet.Partition","text":"Efficiently stores the partition of a vector of elements of type T into disjoint sets.\n\nSupports iterator interface.\n\n\n\n\n\n","category":"type"},{"location":"utils.html","page":"Utilities","title":"Utilities","text":"HierarchicalHotNet.nelems\nHierarchicalHotNet.elems\n\nHierarchicalHotNet.nparts\nHierarchicalHotNet.partrange\nHierarchicalHotNet.partlength\nHierarchicalHotNet.ispartempty\n\nHierarchicalHotNet.pushelem!\nHierarchicalHotNet.closepart!\n\nHierarchicalHotNet.repeat!\nHierarchicalHotNet.IndicesPartition\nHierarchicalHotNet.reset!","category":"page"},{"location":"utils.html#HierarchicalHotNet.nelems","page":"Utilities","title":"HierarchicalHotNet.nelems","text":"nelems(ptn::AbstractPartition)\n\nTotal number of elements in the partition.\n\n\n\n\n\n","category":"function"},{"location":"utils.html#HierarchicalHotNet.elems","page":"Utilities","title":"HierarchicalHotNet.elems","text":"elems(ptn::Partition{T}) where T -> Vector{T}\n\nVector of elements in the partition.\n\nRerturns the vectors as they are stored in ptn: the elements are ordered by their parts (elements from the first part come first etc) and maintain the same order as within each part.\n\n\n\n\n\n","category":"function"},{"location":"utils.html#HierarchicalHotNet.nparts","page":"Utilities","title":"HierarchicalHotNet.nparts","text":"nelems(ptn::AbstractPartition) -> Int\n\nNumber of parts in the partition.\n\nSame as length(ptn).\n\n\n\n\n\n","category":"function"},{"location":"utils.html#HierarchicalHotNet.pushelem!","page":"Utilities","title":"HierarchicalHotNet.pushelem!","text":"pushelem!(ptn::Partition, el) -> ptn\n\nPush the element into the last part of partition.\n\n\n\n\n\n","category":"function"},{"location":"utils.html#HierarchicalHotNet.closepart!","page":"Utilities","title":"HierarchicalHotNet.closepart!","text":"closepart!(ptn::Partition) -> ptn\n\nFinalize the last part of the partition and append the new empty part.\n\nAll subsequent calls to pushelem! will add elements into the new part.\n\n\n\n\n\n","category":"function"},{"location":"utils.html#HierarchicalHotNet.repeat!","page":"Utilities","title":"HierarchicalHotNet.repeat!","text":"repeat!(ptn::Partition, n::Integer) -> ptn\n\nRepeat the parts of ptn n times.\n\njulia> using HierarchicalHotNet\n\njulia> ptn = HierarchicalHotNet.IndicesPartition(5, nparts=1)\n1-element HierarchicalHotNet.Partition{Int64}:\n [1, 2, 3, 4, 5]\n\njulia> HierarchicalHotNet.repeat!(ptn, 3)\n3-element HierarchicalHotNet.Partition{Int64}:\n [1, 2, 3, 4, 5]\n [1, 2, 3, 4, 5]\n [1, 2, 3, 4, 5]\n\n\n\n\n\n","category":"function"},{"location":"utils.html#HierarchicalHotNet.IndicesPartition","page":"Utilities","title":"HierarchicalHotNet.IndicesPartition","text":"Partition of an integer vector\n\n\n\n\n\n","category":"type"},{"location":"utils.html#HierarchicalHotNet.reset!","page":"Utilities","title":"HierarchicalHotNet.reset!","text":"reset!(p::IndicesPartition, n::Integer=nelems(p); nparts::Integer=n) -> p\n\nResets the integer partition p.\n\nIf nparts == 1, the partition is reset into [[1, 2, 3, ..., n]]. If n == nparts, sets the partition to [[1], [2], [3], ..., [n]].\n\n\n\n\n\n","category":"function"}]
}
