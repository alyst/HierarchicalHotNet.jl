var documenterSearchIndex = {"docs":
[{"location":"export.html#export","page":"Export","title":"Export HotNet Networks","text":"","category":"section"},{"location":"export.html","page":"Export","title":"Export","text":"HierarchicalHotNet.export_flowgraph","category":"page"},{"location":"export.html#HierarchicalHotNet.export_flowgraph","page":"Export","title":"HierarchicalHotNet.export_flowgraph","text":"export_flowgraph(tree::SCCTree{T}, threshold::Number,\n                 walkmatrix::AbstractMatrix,\n                 sources::AbstractVector{<:Integer}, sinks::AbstractVector{<:Integer};\n                 orig_diedges::Union{AbstractDataFrame, Nothing} = nothing,\n                 vertices_stats::Union{AbstractDataFrame, Nothing} = nothing,\n                 diedges_stats::Union{AbstractDataFrame, Nothing} = nothing,\n                 flowpaths::Symbol = :skip,\n                 stepmatrix::Union{AbstractMatrix, Nothing} = nothing,\n                 step_threshold::Number = 0.75 * threshold, maxsteps::Integer = 2,\n                 step_sinks::Union{AbstractVector, AbstractSet, Nothing} = nothing,\n                 step_sources::Union{AbstractVector, AbstractSet, Nothing} = nothing,\n                 flow_edges::Bool=false,\n                 pvalue_mw_max::Number=0.05,\n                 pvalue_fisher_max::Number=0.05,\n                 verbose::Bool=false,\n                 pools::Union{ObjectPools, Nothing}=nothing,\n                 mincompsize::Union{Integer, Nothing}=nothing,\n                 exported_sinks::AbstractVector{<:Integer}=sinks\n) -> NamedTuple\n\nCuts the tree at threshold and exports the resulting SCC network as the collection of dataframes.\n\nIf specified, calculates the flows from sources to sinks and returns them as additional edges.\n\nKeyword arguments\n\norig_diedges::AbstractDataFrame: optional collection of the original edges. The metadata from this frame is added to the overlapping diedges of the SCC network.\nvertices_stats::AbstractDataFrame: optional vertices statistics\ndiedges_stats::AbstarctDataFrame: optional directed edges statistics\nflowpaths::Symbol: how the flows should be traced\nskip (default): no tracing\nflowattr: trace the flows (see HierarchicalHotNet.traceflows) and add as flowpaths column to diedges data frame\nsteps: trace the flows (see HierarchicalHotNet.traceflows) and add as extra diedges of type step to diedges data frame\n\nReturns\n\nNamed tuple with fields\n\ncomponents::DataFrame: statistics for Strongly Connected Components\nvertices::DataFrame: network vertices\ndiedges::DataFrame: directed edges\nedges::DataFrame: undirected edges\n\nSee also\n\nHierarchicalHotNet.cut\n\n\n\n\n\n","category":"function"},{"location":"source_sink.html#source_sink","page":"Source → Sink Flows","title":"Source-Sink Analysis","text":"","category":"section"},{"location":"source_sink.html","page":"Source → Sink Flows","title":"Source → Sink Flows","text":"For any edge weight threshold t, cutting the strongly connected components (SCC) tree provides the set of SCC of the original directed weighted network. Within each SCC subnetwork, there is a path from any node to any other node along the edges with weights not smaller than t. The original network may still contain the other edges with weights ≥t, which can connect one SCC subnetwork to the other, but it is not possible to reenter the same SCC again by traveling along these edges (otherwise by definition there is a bigger SCC). In other words, for each t we have a direct acyclic graph of connections between SCCs.","category":"page"},{"location":"source_sink.html","page":"Source → Sink Flows","title":"Source → Sink Flows","text":"This property makes it very convenient to enumerate all paths from one set of nodes (sources) to the other (sinks). It is implemented by the flowgraph() method. One can use it to identify signaling subnetworks that connect one biological data (e.g. interactors of a particular protein) to another (e.g. downstream changes resulting from knock out or overexpressing this protein).","category":"page"},{"location":"source_sink.html","page":"Source → Sink Flows","title":"Source → Sink Flows","text":"The output of flowgraph() is the subnetwork that consists of selected SCCs and the edges that connect these SCCs, plus the list of paths within this subnetwork from source to sink nodes. It could be shown that the path lengths tend to be smaller for the diffusion networks based on the real data than the ones based on the reshuffled node weights.","category":"page"},{"location":"source_sink.html#network_metrics","page":"Source → Sink Flows","title":"Network Metrics","text":"","category":"section"},{"location":"source_sink.html","page":"Source → Sink Flows","title":"Source → Sink Flows","text":"It's is important to have a way to check the relevance of HierarchicalHotNet predictions. For example, one can randomize the input data and show that, at some edge weight threshold t_*, HHotNet predictions based on the real data, H(mathcalD_mathrmreal t_*), demnostrate significantly more order than the ones based on randomized data, H(mathcalD_mathrmperm^i t_*), i=12ldotsN_mathrmperm. If the \"order\" could be expressed as some metric m(H), then we can easily define the p-value for the hypothesis that H(mathcalD_mathrmreal t) is significantly more \"ordered\" than expected by chance:","category":"page"},{"location":"source_sink.html","page":"Source → Sink Flows","title":"Source → Sink Flows","text":"p_m(H(mathcalD_mathrmreal t)) = Pbig(M_mathrmperm(t) geq m(H(mathcalD_mathrmreal t)) big)","category":"page"},{"location":"source_sink.html","page":"Source → Sink Flows","title":"Source → Sink Flows","text":"where M_mathrmperm(t) is a random variable derived from the empirical distribution of m(H(mathcalD_mathrmperm^i t)), i = 1 2 ldots N_mathrmperm. The definition above was given for the case of m(H) growing with the increase of H \"order\". If the metric m decreases as the \"order\" of H grows, P(M geq m(H)) should be changed to P(M leq m(H)).","category":"page"},{"location":"source_sink.html","page":"Source → Sink Flows","title":"Source → Sink Flows","text":"In M.A. Reyna et al (2018), the m_maxmathrmsize(H) metric – the size of the maximal strongly connected component – was used, and it was shown that m_maxmathrmsize(H(mathcalD_mathrmreal t)) is statistically significantly larger than at random for some t_*. treecomp_stats() provides m_maxmathrmsize(t) in maxcomponent_size column. It is also possible to use the total size of top N components (topn_components_sizesum column) or the number of non-trivial (larger than single node) SCCs (ncomponents_nontrivial column) for the same purpose.","category":"page"},{"location":"source_sink.html#sourcesink_metrics","page":"Source → Sink Flows","title":"Flow Metrics","text":"","category":"section"},{"location":"source_sink.html","page":"Source → Sink Flows","title":"Source → Sink Flows","text":"Metrics like m_maxmathrmsize(H) could be used for the analysis of significantly perturbed subnetworks, but they don't allow estimating how strong is the relationship between sources and sinks. The source-to-sink flows analysis requires different metrics. The one that shows good results is the average inverse of flow length:","category":"page"},{"location":"source_sink.html","page":"Source → Sink Flows","title":"Source → Sink Flows","text":"L_mathrmavg^-1(H) = frac1N_mathrmsource cdot N_mathrmsink sum_f in mathrmflows(H) frac1N_mathrmSCC(f)","category":"page"},{"location":"source_sink.html","page":"Source → Sink Flows","title":"Source → Sink Flows","text":"where N_mathrmsource and N_mathrmsink are the numbers of sources and sinks, respectively (so N_mathrmsource cdot N_mathrmsink is the number of all possible distinct flows), mathrmflows(H) are all the source-to-sink flows of H, and N_mathrmSCC(f) is the number of distinct strongly connected components that contain the nodes of the f flow. This metric changes from 1 (all sources and sinks in the same strongly connected component) to 0 (no or infinitely long flows). This metric is available as flow_avginvlen column in the treecomp_stats() output.","category":"page"},{"location":"source_sink.html","page":"Source → Sink Flows","title":"Source → Sink Flows","text":"The alternative metrics for the flow analysis provided by treecomp_stats() are:","category":"page"},{"location":"source_sink.html","page":"Source → Sink Flows","title":"Source → Sink Flows","text":"the average transition probability of the flow (flow_avgweight column):","category":"page"},{"location":"source_sink.html","page":"Source → Sink Flows","title":"Source → Sink Flows","text":"w_mathrmavg flow(H) = frac1N_mathrmsrc cdot N_mathrmsink sum_f in mathrmflows(H) min big( w(mathrmsource(f) mathrmsink(f)) w_max big)","category":"page"},{"location":"source_sink.html","page":"Source → Sink Flows","title":"Source → Sink Flows","text":"where w(i j) is the transition probability from i-th to j-th node in the random walk with restart. The distribution of w(i j) is essentially non-gaussian, and to limit the strong influence of a few \"outliers\" on the total w_mathrmavg flow(H), some w_max constant is used.","category":"page"},{"location":"source_sink.html","page":"Source → Sink Flows","title":"Source → Sink Flows","text":"the average flow transition probability per SCC (flow_avghopweight column):","category":"page"},{"location":"source_sink.html","page":"Source → Sink Flows","title":"Source → Sink Flows","text":"w_mathrmavg hop(H) = frac1N_mathrmsrc cdot N_mathrmsink sum_f in mathrmflows(H) fracmin big( w(mathrmsource(f) mathrmsink(f)) w_max big)N_mathrmSCC(f)","category":"page"},{"location":"source_sink.html","page":"Source → Sink Flows","title":"Source → Sink Flows","text":"HierarchicalHotNet.flowgraph\nHierarchicalHotNet.flowgraph!\nHierarchicalHotNet.nflows\nHierarchicalHotNet.traceflows\nHierarchicalHotNet.traceflows!","category":"page"},{"location":"source_sink.html#HierarchicalHotNet.traceflows","page":"Source → Sink Flows","title":"HierarchicalHotNet.traceflows","text":"traceflows(step_adjmtx::AbstractMatrix, steptest::EdgeTest,\n           walk_adjmtx::AbstractMatrix, walktest::EdgeTest;\n           kwargs...) -> Dict{Diedge, Partition{Int}}\n\nTrace the random walk (specified by walk_adjmtx and walktest) steps in the original graph (given by step_adjmtx and steptest).\n\nSee HierarchicalHotNet.traceflows! for the detailed description.\n\n\n\n\n\n","category":"function"},{"location":"source_sink.html#HierarchicalHotNet.traceflows!","page":"Source → Sink Flows","title":"HierarchicalHotNet.traceflows!","text":"traceflows!(flow2paths::AbstractDict{Diedge, Partition{Int}},\n            step_adjmtx::AbstractMatrix,\n            steptest::EdgeTest,\n            walk_adjmtx::AbstractMatrix,\n            walktest::EdgeTest;\n            sources::Union{AbstractVector, AbstractSet, Nothing} = nothing,\n            sinks::Union{AbstractVector, AbstractSet, Nothing} = nothing,\n            maxsteps::Integer=2) -> Dict{Diedge, Partition{Int}}\n\nTrace the random walk (specified by walk_adjmtx and walktest) steps in the original graph (given by step_adjmtx and steptest).\n\nKeyword arguments\n\nsources (optional): the indices of vertices to use as path starts. If not specified, all vertices are used as path starts.\nsinks (optional): the indices of vertices to use as path ends. If not specified, all vertices are used as path ends.\nmaxsteps=2: maximal number of steps in a traced path, longer paths are discarded.\n\nReturns the mapping from the flow diedges to the HierarchicalHotNet.Partition object. Each part corresponds to the path, from diedge start to diedge end, in the original network, and the part elements are the indices of the intermedidate vertices along the path (start and end not included).\n\n\n\n\n\n","category":"function"},{"location":"network_diffusion.html#netdiff","page":"Network Diffusion","title":"Network Diffusion","text":"","category":"section"},{"location":"network_diffusion.html","page":"Network Diffusion","title":"Network Diffusion","text":"Network diffusion is an efficient way to model signal propagation in molecular networks. While it could not be regarded as an accurate simulation of biological system, network diffusion allows assessing complex molecular networks and revealing various topological structures, such as hubs, communities etc.","category":"page"},{"location":"network_diffusion.html","page":"Network Diffusion","title":"Network Diffusion","text":"Currently, HierarchicalHotNet.jl package implements random walk with restart diffusion method. The input weighted graph is processed by stepmatrix() function, which prepares the adjacency matrix for the random walk. The resulting matrix is then submitted to random_walk_with_restart() method that generates the matrix of random walk transition probabilities.","category":"page"},{"location":"network_diffusion.html","page":"Network Diffusion","title":"Network Diffusion","text":"Alternatively, one can use stabilized_stepmatrix() method to weight the edges of the original network according to how frequently their are being utilized during the random walk.","category":"page"},{"location":"network_diffusion.html#netweights","page":"Network Diffusion","title":"Node and edge weights","text":"","category":"section"},{"location":"network_diffusion.html","page":"Network Diffusion","title":"Network Diffusion","text":"TODO","category":"page"},{"location":"network_diffusion.html","page":"Network Diffusion","title":"Network Diffusion","text":"HierarchicalHotNet.stepmatrix\nHierarchicalHotNet.random_walk_matrix\nHierarchicalHotNet.similarity_matrix\nHierarchicalHotNet.stabilized_stepmatrix\nHierarchicalHotNet.neighborhood_weights","category":"page"},{"location":"network_diffusion.html#HierarchicalHotNet.stepmatrix","page":"Network Diffusion","title":"HierarchicalHotNet.stepmatrix","text":"stepmatrix(g::Union{AbstractSimpleWeightedGraph, AbstractMatrix};\n           inedge_weights::Union{AbstractVector, Nothing} = nothing,\n           normalize_weights::Bool = true) -> AbstractMatrix\n\nConstruct the step probabilities matrix for the random walk on graph g.\n\nReturns matrix S, where s_ij is the probability to travel along the edge (v_j v_i)  g.\n\ninedge_weights::AbstractVector: (optional) an array of factors  for each vertex to scale the weights of incoming edges\nnormalize_weights=true: normalize the weights of the columns in  the final output, so that it sums to 1\n\n\n\n\n\n","category":"function"},{"location":"network_diffusion.html#HierarchicalHotNet.random_walk_matrix","page":"Network Diffusion","title":"HierarchicalHotNet.random_walk_matrix","text":"random_walk_matrix(g::AbstractSimpleWeightedGraph,\n                   restart_probability::Number=0.1;\n                   stepmtx_kwargs...) -> Matrix{Float64}\n\nCalculate the stationary distribution of vertex transition probabilities for a random walk with restart on graph g.\n\nReturns the matrix W, where w_i j is the v_j  v_i transition probability along the edges of the graph g.\n\n\n\n\n\n","category":"function"},{"location":"network_diffusion.html#HierarchicalHotNet.similarity_matrix","page":"Network Diffusion","title":"HierarchicalHotNet.similarity_matrix","text":"similarity_matrix(g::AbstractSimpleWeightedGraph,\n                  node_weights::AbstractVector;\n                  restart_probability::Union{Number, Nothing} = nothing,\n                  stepmtx_kwargs...) -> Matrix{Float64}\n\nCalculate the matrix of node transition probabilities for the random walk with restart taking into account the node restarting probabilities node_weights.\n\nReturns the matrix W, where w_i j is the probability of v_j  v_i transition considering all possible starting vertices of graph g.\n\nParameters\n\nnode_weights::AbstractVector: vector of node restart probabilities\nrestart_probability: random walk restart probability\nstepmatrix() keyword arguments\n\nSee also\n\nHierarchicalHotNet.randomwalkmatrix\n\n\n\n\n\n","category":"function"},{"location":"network_diffusion.html#HierarchicalHotNet.stabilized_stepmatrix","page":"Network Diffusion","title":"HierarchicalHotNet.stabilized_stepmatrix","text":"stabilized_stepmatrix(g::AbstractSimpleWeightedGraph,\n                      node_weights::AbstractVector;\n                      restart_probability::Union{Number, Nothing} = nothing,\n                      stepmtx_kwargs...) -> Matrix{Float64}\n\nCalculate the matrix for the node transition probabilities at each iteration of the random walk with restart taking into account the probabilities of visiting the nodes.\n\nReturns matrix S. If w is the node starting probabilities (node_weights), S is the step matrix, and W is the corresponding transition probabilities matrix for a random walk with restart, then\n\n    S = (1-r) S  mathrmdiag(W  w) + r mathrmdiag(w)\n\nParameters\n\nnode_weights::AbstractVector: vector of node restart probabilities\nrestart_probability: random walk restart probability\nnode_weights_diffused: precalculated node visiting weights for a random walk with restart (in case the random matrix is already calculated before)\nstepmatrix() keyword arguments\n\n\n\n\n\n","category":"function"},{"location":"network_diffusion.html#HierarchicalHotNet.neighborhood_weights","page":"Network Diffusion","title":"HierarchicalHotNet.neighborhood_weights","text":"neighborhood_weights(adjmtx::AbstractMatrix, g::AbstractGraph) -> Vector{Float64}\n\nGiven the adjmtx adjacency matrix for the graph g and the graph g, calculate the sum of the weights of the g outgoing edges that are also present in g. Returns the vector with the weights sum for each vertex.\n\nThe graphs have to have the same number of nodes.\n\n\n\n\n\n","category":"function"},{"location":"network_diffusion.html#permweights","page":"Network Diffusion","title":"Node weights permutation","text":"","category":"section"},{"location":"network_diffusion.html","page":"Network Diffusion","title":"Network Diffusion","text":"One way to confirm the relevance of network diffusion-based predictions is to show that the results based on real the data differ significantly from the ones based on randomized data, where no meaningful patterns are expected.","category":"page"},{"location":"network_diffusion.html","page":"Network Diffusion","title":"Network Diffusion","text":"In the original HierarchicalHotNet paper by Reina et al (2018) it is proposed to group the vertices with similar in- and out-degrees into bins (see vertexbins()) and randomly shuffle the weights of the vertices within each bin (see randpermgroups()).","category":"page"},{"location":"network_diffusion.html","page":"Network Diffusion","title":"Network Diffusion","text":"This scheme would reassign the weights of hub vertices to other hubs, and low-degree vertices – to other low-degree vertices. So, in addition to preserving the overall distribution of node weights, the correlation of node degree and its weight would be kept too. However, such reshuffling should eliminate the correlation of paths between the specific nodes and the node weights along these paths.","category":"page"},{"location":"network_diffusion.html","page":"Network Diffusion","title":"Network Diffusion","text":"HierarchicalHotNet.vertexbins\nHierarchicalHotNet.randpermgroups!\nHierarchicalHotNet.randpermgroups","category":"page"},{"location":"network_diffusion.html#HierarchicalHotNet.vertexbins","page":"Network Diffusion","title":"HierarchicalHotNet.vertexbins","text":"vertexbins(g::AbstractSimpleWeightedGraph,\n           vertices::AbstractArray{Int}=1:nv(g);\n           nbins::Integer=10, by::Symbol=:out, method=:tree) ->\n    IndicesPartition\n\nPartition the vertices of the weighted graph g into nbins bins, so that the vertices of the same bin have similar sum of edge weights.\n\nKeyword arguments\n\nnbins::Integer: the number of vertex bins. Use nbins &ge; 1 for  bigger (nv &ge; 1) networks\nby::Symbol: what edges to consider for grouping vertices. The supported options are:\n:out (default, as in the original paper) – use only the outgoing edges\n:in – use only the incoming edges\n:outXin (recommended) – use all edges, so that the vertices of the same bin have similar sums of both incoming and outgoing edges\nmethod::Symbol: the method for binning vertices\n:sort (as in the original paper) – order the vertices by the sum of weights, then split the sorted array into equal bins. This method doesn't handle the by=:outXin well.\n:tree (default) – build the hierarchical tree of vertices based on their sum of weights, then cut the tree to get the requested number of bins.\n\n\n\n\n\n","category":"function"},{"location":"network_diffusion.html#HierarchicalHotNet.randpermgroups!","page":"Network Diffusion","title":"HierarchicalHotNet.randpermgroups!","text":"randpermgroups!(v::AbstractVector{Int}, groups::AbstractPartition) -> v\n\nRandomly reshuffle the elements of groups within each group and put the result into v, group by group.\n\n\n\n\n\n","category":"function"},{"location":"network_diffusion.html#HierarchicalHotNet.randpermgroups","page":"Network Diffusion","title":"HierarchicalHotNet.randpermgroups","text":"randpermgroups(groups::AbstractPartition) -> Vector{Int}\n\nRandomly reshuffle the elements of groups within each group.\n\n\n\n\n\n","category":"function"},{"location":"stats.html#netstats","page":"Statistics","title":"Network Statistics","text":"","category":"section"},{"location":"stats.html","page":"Statistics","title":"Statistics","text":"Permutation allows generating randomized data that mimcs the key properties of the original vertex weight distribution. With enough permutations, it's possible to analyze how different are the results of network diffusion based on real weights in comparison to permuted weights.","category":"page"},{"location":"stats.html","page":"Statistics","title":"Statistics","text":"The package allows doing this analysis at the level of individual vertices (HierarchicalHotNet.vertex_stats), directed edges (HierarchicalHotNet.diedge_stats), connected components (HierarchicalHotNet.conncomponents_stats) etc.","category":"page"},{"location":"stats.html","page":"Statistics","title":"Statistics","text":"The statistcs from multiple permutation and cutting thresholds could be binned  (HierarchicalHotNet.bin_treecut_stats) and then aggregated for calculating the quantiles of resulting distributions (HierarchicalHotNet.aggregate_treecut_binstats). Finally, HierarchicalHotNet.extreme_treecut_stats can find the edge cutting threshold with the maximal difference between the real and permuted weights.","category":"page"},{"location":"stats.html","page":"Statistics","title":"Statistics","text":"HierarchicalHotNet.vertex_stats\nHierarchicalHotNet.diedge_stats\nHierarchicalHotNet.conncomponents_stats\nHierarchicalHotNet.treecut_stats\nHierarchicalHotNet.treecut_compstats\nHierarchicalHotNet.bin_treecut_stats\nHierarchicalHotNet.aggregate_treecut_binstats\nHierarchicalHotNet.extreme_treecut_stats","category":"page"},{"location":"stats.html#HierarchicalHotNet.vertex_stats","page":"Statistics","title":"HierarchicalHotNet.vertex_stats","text":"vertex_stats(weights::AbstractVector{<:Number},\n             walkweights::AbstractVector{<:Number},\n             [permweights::AbstractMatrix{<:Number}],\n             [walkpermweights::AbstractMatrix{<:Number}]) -> DataFrame\n\nCalculates statistics for the permuted vertex weights distribution and how it is different from the actual weights.\n\nReturns the data frame with per-vertex mean, standard deviation, median, MAD and the probability that permuted value is greater/lower than the corresponding real value for the weights of the original matrix (weights) as well as random walk matrix weights (walkweights).\n\nParameters\n\nweights: weights of the vertices in the original network\nwalkweights: weights of the vertices after network diffusion analysis (stationary random walk distribution)\npermweights: matrix of permuted weights; rows correspond to vertices, columns – to permutations\nwalkpermweights: matrix of vertex weights based on network diffusion analysis using permweights as input; rows correspond to vertices, columns to permutations\n\n\n\n\n\n","category":"function"},{"location":"stats.html#HierarchicalHotNet.diedge_stats","page":"Statistics","title":"HierarchicalHotNet.diedge_stats","text":"diedge_stats(weights::AbstractVector{<:Number},\n             walkweights::AbstractVector{<:Number},\n             [permweights::AbstractMatrix{<:Number}],\n             [walkpermweights::AbstractMatrix{<:Number}]) -> DataFrame\n\nCalculates statistics for the directed edges permuted weights distribution and how it is different from the actual weights of directed edges.\n\nThe output is similar to HieararchicalHotNet.vertex_stats for vertices.\n\n\n\n\n\n","category":"function"},{"location":"stats.html#HierarchicalHotNet.conncomponents_stats","page":"Statistics","title":"HierarchicalHotNet.conncomponents_stats","text":"Calculate per-connected component statistics.\n\n\n\n\n\n","category":"function"},{"location":"stats.html#HierarchicalHotNet.treecut_stats","page":"Statistics","title":"HierarchicalHotNet.treecut_stats","text":"Calculate SCC network statistic for each cutting threshold of tree.\n\n\n\n\n\n","category":"function"},{"location":"stats.html#HierarchicalHotNet.bin_treecut_stats","page":"Statistics","title":"HierarchicalHotNet.bin_treecut_stats","text":"bin_treecut_stats(cutstats_df::AbstractDataFrame) -> DataFrame\n\nBin treecut thresholds and calculate average statistics in each bin.\n\nTakes the output of HieararchicalHotNet.treecut_stats from multiple SCC trees (discriminated by by_cols), identifies the bind for treecut thresholds and calculates the average metric values (stat_cols) within each bin.\n\n\n\n\n\n","category":"function"},{"location":"stats.html#HierarchicalHotNet.aggregate_treecut_binstats","page":"Statistics","title":"HierarchicalHotNet.aggregate_treecut_binstats","text":"aggregate_treecut_binstats(binstats_df::AbstractDataFrame) -> DataFrame\n\nAggregate the binned treecut statistics across multiple trees.\n\nTakes binstats_df, the output of HierarchicalHotNet.bin_treecut_stats, and calculates the metric values for the specified quantiles.\n\n\n\n\n\n","category":"function"},{"location":"stats.html#HierarchicalHotNet.extreme_treecut_stats","page":"Statistics","title":"HierarchicalHotNet.extreme_treecut_stats","text":"extreme_treecut_stats(stats_df::AbstractDataFrame) -> DataFrame\n\nCalculate the cut threshold and corresponding metric value, where the difference between real (taken from stats_df) and permutation metrics (taken from perm_aggstats_df) are maximal/minimal (depending on the metric).\n\nArguments\n\nstats_df: tree statistics calculated by treecut_stats\nperm_aggstats_df: aggregated binned permutated tree statistics calculated by aggregate_treecut_binstats\nextra_join_cols: optional columns, in addition to :threshold_bin to use for joining stats_df and perm_aggstats_df\nmetric_cols: columns of stats_df and perm_aggstats_df containing treecut metrics  to consider for threshold calculation (see TreecutMetrics)\nstart_maxquantile: if specified, calculates (in addition to minimal and maximal metric)  the metric corresponding to the given quantile as well as 1 - quantile\nthreshold_range: if given, contrains metric statistic calculation to given min/max thresholds\nthreshold_weight: optional function that takes stats_df row and returns the prior weight of the corresponding cut threshold\n\n\n\n\n\n","category":"function"},{"location":"index.html#HierarchicalHotNet.jl-package","page":"Introduction","title":"HierarchicalHotNet.jl package","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"HierarchicalHotNet.jl implements Hierarchical HotNet algorithm (see the original paper by M.A. Reyna et al (2018)) with a few permormance optimization and additional features.","category":"page"},{"location":"index.html#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Network-based analysis is a powerful bioinformatic tool to put high-throughput experimental data in the context of current knowledge of cellular interactions and identify potential connections between the perturbed genes.","category":"page"},{"location":"index.html#Workflow","page":"Introduction","title":"Workflow","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"load the network of gene/protein functional interactions, e.g. ReactomeFI or STRING protein links.\nuse experimental data to assign weights to the genes/proteins in the network\ngenerate randomized data by reshuffling node weights\napply random walk with restart to get the stationary distribution of vertex visiting probabilities and edge transition probabilities\nuse random walk-based weighted graphs to generate trees of Strongly Connected Components\nanalyze the distribution of SCC metrics at each cutting threshold for read data-based SCC tree and the randomized ones\ncut the SCC tree at the optimal edge threshold and export the result as a collection of data frames","category":"page"},{"location":"scctree.html#scctree","page":"SCC Tree","title":"Strongly Connected Components Tree","text":"","category":"section"},{"location":"scctree.html","page":"SCC Tree","title":"SCC Tree","text":"HierarchicalHotNet.SCCTree\nHierarchicalHotNet.scctree\nHierarchicalHotNet.cut","category":"page"},{"location":"scctree.html#HierarchicalHotNet.SCCTree","page":"SCC Tree","title":"HierarchicalHotNet.SCCTree","text":"The tree of strongly connected components. Organizes the strongly connected components of the weighted directed graph into a tree.\n\nCutting the tree at specific threshold with cut gives the corresponding strongly connected components. The root of the tree corresponds to the weakest threshold.\n\n\n\n\n\n","category":"type"},{"location":"scctree.html#HierarchicalHotNet.scctree","page":"SCC Tree","title":"HierarchicalHotNet.scctree","text":"scctree(g::Union{AbstractSimpleWeightedGraph, AbstractMatrix};\n        method=:bisect, skipval=0, rev=false) -> SCCTree\n\nComputes the hierarchical decomposition of the weighted directed graph g into strongly connected components.\n\nSupports weighted graph objects as well as their adjacency matrix representations.\n\nKeyword arguments\n\nmethod::Symbol (defaults to :bisect): the method for partitioning.  The supported methods are :bisect (the fastest) and :bottomup (slow,  but simpler).\nskipval::Number (defaults to zero): what value of the adjacency matrix  should be treated as \"no edge\".\nrev::Bool (defaults to false): if true, bigger edges weights are considered  weaker than smaller ones\n\n\n\n\n\n","category":"function"},{"location":"scctree.html#HierarchicalHotNet.cut","page":"SCC Tree","title":"HierarchicalHotNet.cut","text":"cut(tree::SCCTree, threshold; minsize=1) -> IndicesPartition\n\nCuts the tree at the given edge weight threshold to get the corresponding strongly connected components of the original graph.\n\nKeyword arguments\n\nminsize: the minimal number of vertices in the component. Smaller connected components are skipped. By default returns components of any size.\n\n\n\n\n\n","category":"function"},{"location":"utils.html#partition","page":"Utilities","title":"Partitions","text":"","category":"section"},{"location":"utils.html","page":"Utilities","title":"Utilities","text":"Partition type provides an efficient container for storing multiple vectors of elements. The advantage over Vector{Vector{T}} is that internally it uses single Vector{T} to store the elements of all of its parts. The disadvantage is that it doesn't support adding or removing elements to/from arbitrary part, only the last part could be modified. Partition supports iterator interface for iterating over its parts as well as parts indexing and filter! for elements filtering.","category":"page"},{"location":"utils.html","page":"Utilities","title":"Utilities","text":"HierarchicalHotNet.AbstractPartition\nHierarchicalHotNet.Partition\nHierarchicalHotNet.PartitionPart","category":"page"},{"location":"utils.html#HierarchicalHotNet.AbstractPartition","page":"Utilities","title":"HierarchicalHotNet.AbstractPartition","text":"Base class for partitions of elements of type T.\n\n\n\n\n\n","category":"type"},{"location":"utils.html#HierarchicalHotNet.Partition","page":"Utilities","title":"HierarchicalHotNet.Partition","text":"Efficiently stores the partition of a vector of elements of type T into disjoint sets.\n\nSupports iterator interface.\n\n\n\n\n\n","category":"type"},{"location":"utils.html#HierarchicalHotNet.PartitionPart","page":"Utilities","title":"HierarchicalHotNet.PartitionPart","text":"The type of parts returned by Partition{T}\n\n\n\n\n\n","category":"type"},{"location":"utils.html","page":"Utilities","title":"Utilities","text":"HierarchicalHotNet.nelems\nHierarchicalHotNet.elems\n\nHierarchicalHotNet.nparts\nHierarchicalHotNet.partrange\nHierarchicalHotNet.partlength\nHierarchicalHotNet.ispartempty\n\nHierarchicalHotNet.pushelem!\nHierarchicalHotNet.closepart!\n\nHierarchicalHotNet.repeat!\nHierarchicalHotNet.IndicesPartition\nHierarchicalHotNet.reset!","category":"page"},{"location":"utils.html#HierarchicalHotNet.nelems","page":"Utilities","title":"HierarchicalHotNet.nelems","text":"nelems(ptn::AbstractPartition)\n\nTotal number of elements in the partition.\n\n\n\n\n\n","category":"function"},{"location":"utils.html#HierarchicalHotNet.elems","page":"Utilities","title":"HierarchicalHotNet.elems","text":"elems(ptn::Partition{T}) where T -> Vector{T}\n\nVector of elements in the partition.\n\nRerturns the vectors as they are stored in ptn: the elements are ordered by their parts (elements from the first part come first etc) and maintain the same order as within each part.\n\n\n\n\n\n","category":"function"},{"location":"utils.html#HierarchicalHotNet.nparts","page":"Utilities","title":"HierarchicalHotNet.nparts","text":"nelems(ptn::AbstractPartition) -> Int\n\nNumber of parts in the partition.\n\nSame as length(ptn).\n\n\n\n\n\n","category":"function"},{"location":"utils.html#HierarchicalHotNet.pushelem!","page":"Utilities","title":"HierarchicalHotNet.pushelem!","text":"pushelem!(ptn::Partition, el) -> ptn\n\nPush the element into the last part of partition.\n\n\n\n\n\n","category":"function"},{"location":"utils.html#HierarchicalHotNet.closepart!","page":"Utilities","title":"HierarchicalHotNet.closepart!","text":"closepart!(ptn::Partition) -> ptn\n\nFinalize the last part of the partition and append the new empty part.\n\nAll subsequent calls to pushelem! will add elements into the new part.\n\n\n\n\n\n","category":"function"},{"location":"utils.html#HierarchicalHotNet.repeat!","page":"Utilities","title":"HierarchicalHotNet.repeat!","text":"repeat!(ptn::Partition, n::Integer) -> ptn\n\nRepeat the parts of ptn n times.\n\njulia> using HierarchicalHotNet\n\njulia> ptn = HierarchicalHotNet.IndicesPartition(5, nparts=1)\n1-element HierarchicalHotNet.Partition{Int64}:\n [1, 2, 3, 4, 5]\n\njulia> HierarchicalHotNet.repeat!(ptn, 3)\n3-element HierarchicalHotNet.Partition{Int64}:\n [1, 2, 3, 4, 5]\n [1, 2, 3, 4, 5]\n [1, 2, 3, 4, 5]\n\n\n\n\n\n","category":"function"},{"location":"utils.html#HierarchicalHotNet.IndicesPartition","page":"Utilities","title":"HierarchicalHotNet.IndicesPartition","text":"Partition of an integer vector\n\n\n\n\n\n","category":"type"},{"location":"utils.html#HierarchicalHotNet.reset!","page":"Utilities","title":"HierarchicalHotNet.reset!","text":"reset!(p::IndicesPartition, n::Integer=nelems(p); nparts::Integer=n) -> p\n\nResets the integer partition p.\n\nIf nparts == 1, the partition is reset into [[1, 2, 3, ..., n]]. If n == nparts, sets the partition to [[1], [2], [3], ..., [n]].\n\n\n\n\n\n","category":"function"}]
}
